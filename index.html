<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Watts–Strogatz Generator</title>

  <!-- vis-network for visualization -->
  <link rel="stylesheet" href="https://unpkg.com/vis-network/styles/vis-network.min.css" />
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>

  <style>
    :root{
      --bg:#0f1724;
      --card:#0b1220;
      --accent:#22c1c3;
      --muted:#9aa4b2;
      --text:#e6eef6;
    }
    html,body{height:100%}
    body{
      margin:0;
      font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
      background: linear-gradient(180deg,#071025 0%, #081127 100%);
      color:var(--text);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      display:flex;
      gap:18px;
      padding:22px;
      box-sizing:border-box;
      align-items:flex-start;
      justify-content:center;
    }

    .panel{
      width:360px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.03);
      padding:18px;
      border-radius:12px;
      box-shadow:0 6px 30px rgba(2,6,23,0.6);
    }
    h1{margin:0 0 10px 0; font-size:18px}
    label{display:block; font-size:13px; color:var(--muted); margin-top:12px}
    input[type="number"], input[type="text"], select {
      width:100%;
      box-sizing:border-box;
      padding:8px 10px;
      margin-top:6px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      background:transparent;
      color:var(--text);
      font-size:14px;
    }
    .row{display:flex; gap:8px}
    .btn{
      display:inline-block;
      margin-top:12px;
      padding:8px 12px;
      border-radius:8px;
      border:0;
      background:linear-gradient(90deg,var(--accent),#5af0d4);
      color:#042226;
      font-weight:600;
      cursor:pointer;
      box-shadow:0 6px 20px rgba(34,193,195,0.12);
    }
    .small{font-size:13px; color:var(--muted); margin-top:8px}
    #network {
      width:900px;
      height:820px;
      border-radius:12px;
      /* position: relative; */
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.03);
      box-shadow: 0 10px 40px rgba(2,6,23,0.6);
    }
    /* .vis-network{ */
      /* position: fixed; */
    /* } */
    .stats{
      margin-top:12px;
      padding:12px;
      border-radius:8px;
      background:rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.02);
      color:var(--muted);
      font-size:14px;
    }
    .error{color:#ff6b6b; margin-top:8px; font-size:13px}
    footer{margin-top:14px; font-size:12px; color:var(--muted)}
    @media (max-width:1200px){
      body{flex-direction:column; align-items:center}
      #network{width:92vw; height:64vh}
      .panel{width:92vw; max-width:560px}
    }
  </style>
</head>
<body>

  <div class="panel">
    <h1>Watts–Strogatz Generator</h1>
    <div class="small">Set n, k, p, choose layout and press <b>Generate</b>.</div>

    <label>Number of nodes (n)</label>
    <input id="inp-n" type="number" min="3" step="1" value="30">

    <label>Nearest neighbors (k) — must be even &lt; n</label>
    <input id="inp-k" type="number" min="2" step="2" value="4">

    <label>Rewiring probability (p) — 0.0 to 1.0</label>
    <input id="inp-p" type="text" value="0.1" placeholder="0.1">

    <label>Layout</label>
    <select id="inp-layout">
      <option value="circular">circular</option>
      <option value="random">random</option>
      <option value="physics">physics (force)</option>
    </select>

    <div style="display:flex; gap:8px; align-items:center;">
      <button id="btn-gen" class="btn">Generate</button>
      <button id="btn-download" class="btn" style="background:transparent;color:var(--text);border:1px solid rgba(255,255,255,0.04)">Download PNG</button>
    </div>

    <div id="err" class="error" style="display:none"></div>

    <div class="stats" id="stats">
      <div><b>Clustering coeff:</b> <span id="stat-clust">-</span></div>
      <div><b>Avg shortest path (L) on largest CC:</b> <span id="stat-l">-</span></div>
      <div style="margin-top:6px;color:var(--muted);font-size:13px">If the graph is disconnected, calculations are done on the largest connected component.</div>
    </div>

  </div>

  <div id="network" title="Graph visualization"></div>

<script>
/* ---------- Utilities & WS generation ---------- */

function randint(n){ return Math.floor(Math.random()*n); }
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

function makeRingLattice(n, k){
  // returns adjacency as array of Sets
  const adj = Array.from({length:n}, ()=> new Set());
  const half = Math.floor(k/2);
  for(let u=0; u<n; u++){
    for(let i=1;i<=half;i++){
      const v = (u + i) % n;
      adj[u].add(v);
      adj[v].add(u);
    }
  }
  return adj;
}

function wattsStrogatz(n,k,p, allowSelf=false){
  // n nodes, k must be even, p in [0,1]
  // if(k >= n) throw new Error("k must be < n");
  if(k % 2 !== 0) throw new Error("k must be even");
  const adj = makeRingLattice(n,k);
  const half = k/2;

  // For each node u, consider clockwise neighbors only to avoid double-rewiring
  for(let u=0; u<n; u++){
    for(let i=1;i<=half;i++){
      const v = (u + i) % n;

      // only rewire the directed edge u->v when u < v in ring sense? We simply ensure each pair considered once:
      // We'll rewire only if (u < v) modulo n when walking clockwise from u: this block already iterates only those edges.
      if(Math.random() < p){
        // remove edge u-v
        adj[u].delete(v);
        adj[v].delete(u);

        // choose new w: random node not equal to u and not already connected to u
        const possible = [];
        for(let w=0; w<n; w++){
          if(w === u) continue;
          if(!allowSelf && w === u) continue;
          if(!adj[u].has(w)) possible.push(w);
        }
        if(possible.length === 0){
          // no possible rewire; restore original edge
          adj[u].add(v);
          adj[v].add(u);
        } else {
          const w = possible[randint(possible.length)];
          adj[u].add(w);
          adj[w].add(u);
        }
      }
    }
  }
  return adj;
}

/* ---------- Graph metrics ---------- */

function largestConnectedComponent(adj){
  const n = adj.length;
  const seen = new Array(n).fill(false);
  let best = [];
  for(let i=0;i<n;i++){
    if(seen[i]) continue;
    const q=[i]; seen[i]=true;
    const comp=[i];
    while(q.length){
      const x=q.shift();
      for(const nb of adj[x]){
        if(!seen[nb]){
          seen[nb]=true;
          q.push(nb);
          comp.push(nb);
        }
      }
    }
    if(comp.length > best.length) best = comp;
  }
  return best;
}

function averageClustering(adj){
  const n = adj.length;
  let total = 0;
  let count = 0;
  for(let u=0; u<n; u++){
    const neighbors = Array.from(adj[u]);
    const d = neighbors.length;
    if(d < 2) continue;
    let links = 0;
    // count edges among neighbors
    for(let i=0;i<neighbors.length;i++){
      for(let j=i+1;j<neighbors.length;j++){
        const a = neighbors[i], b = neighbors[j];
        if(adj[a].has(b)) links++;
      }
    }
    const possible = d*(d-1)/2;
    total += links / possible;
    count++;
  }
  if(count === 0) return 0;
  return total / count;
}

function bfsDistancesFrom(adj, src, allowedSet = null){
  // BFS and return distance array (Infinity for unreachable)
  const n = adj.length;
  const dist = new Array(n).fill(Infinity);
  const q = [src];
  dist[src]=0;
  while(q.length){
    const u = q.shift();
    for(const v of adj[u]){
      if(allowedSet && !allowedSet.has(v)) continue;
      if(dist[v] === Infinity){
        dist[v] = dist[u] + 1;
        q.push(v);
      }
    }
  }
  return dist;
}

function averageShortestPathLengthOnComponent(adj, component){
  // component: array of node indices (largest CC)
  if(component.length <= 1) return 0;
  const allowed = new Set(component);
  const m = component.length;
  let sum = 0;
  // For each node in component, BFS limited to allowed, sum distances to nodes with higher index to avoid double counting
  for(let i=0;i<m;i++){
    const u = component[i];
    const dist = bfsDistancesFrom(adj, u, allowed);
    for(let j=0; j<m; j++){
      const v = component[j];
      if(u === v) continue;
      sum += dist[v];
    }
  }
  // sum has distances counted twice (u->v and v->u), so divide by 2
  const pairs = m * (m - 1) / 2;
  return sum / (2 * pairs);
}

/* ---------- Visualization with vis-network ---------- */

let network = null;
function renderVis(adj, layout){
  const n = adj.length;
  const nodes = [];
  const edges = [];
  for(let i=0;i<n;i++){
    nodes.push({id:i, label: String(i)});
    for(const j of adj[i]){
      if(j > i) edges.push({from:i, to:j});
    }
  }

  // handle positions for circular or random layouts
  const data = {nodes: new vis.DataSet(nodes), edges: new vis.DataSet(edges)};
  const container = document.getElementById('network');

  const options = {
    nodes: {
      shape: 'dot',
      size: 10,
      font:{color:'#dfefff', size:12}
    },
    edges: {
      color: {color:'#c3d3df'},
      width: 1,
      smooth: {type: 'continuous'}
    },
    physics: {
      enabled: layout === 'physics',
      stabilization: {iterations: 200}
    },
    interaction: {hover:true, multiselect:true}
  };

  // create network
  if(network) network.destroy();
  network = new vis.Network(container, data, options);

  if(layout === 'circular'){
    // compute positions on a circle
    const positions = {};
    const R = Math.min(container.clientWidth, container.clientHeight) / 2.6;
    const cx = container.clientWidth / 2;
    const cy = container.clientHeight / 2;
    for(let i=0;i<n;i++){
      const theta = (2*Math.PI*i)/n;
      positions[i] = {x: cx + R*Math.cos(theta), y: cy + R*Math.sin(theta)};
    }
    network.setOptions({physics:{enabled:false}});
    network.setData(data);
    network.once('afterDrawing', ()=>{
      network.setOptions({physics:{enabled:false}});
      network.moveTo({position:{x:0,y:0}});
    });
    // apply positions
    network.setData(data);
    network.stopSimulation();
    network.setOptions({physics:{enabled:false}});
    network.setData(data);
    network.setOptions({physics:{enabled:false}});
    network.storePositions();
    network.moveTo();
    // directly set positions
    for(const nObj of nodes){ network.body.nodes[nObj.id].x = positions[nObj.id].x; network.body.nodes[nObj.id].y = positions[nObj.id].y;}
    network.redraw();
  } else if(layout === 'random'){
    // random positions, disable physics
    network.setOptions({physics:{enabled:false}});
    const positions = {};
    for(let i=0;i<n;i++){
      positions[i] = {x: (Math.random()-0.5) * container.clientWidth * 0.9, y: (Math.random()-0.5) * container.clientHeight * 0.9};
    }
    for(const nObj of nodes){ network.body.nodes[nObj.id].x = positions[nObj.id].x; network.body.nodes[nObj.id].y = positions[nObj.id].y;}
    network.redraw();
  } else {
    // physics: let vis compute layout
    network.setOptions({physics:{enabled:true, solver:'forceAtlas2Based', stabilization:{iterations:200}}});
  }
}

/* ---------- UI wiring ---------- */

function showError(msg){
  const el = document.getElementById('err');
  if(!msg){ el.style.display='none'; el.innerText=''; }
  else { el.style.display='block'; el.innerText=msg; }
}

function updateStats(clust, L){
  document.getElementById('stat-clust').innerText = (clust===null || clust === '-' || typeof clust !== 'number' ? '-' : clust.toFixed(4));
  document.getElementById('stat-l').innerText = (L===null || L === '-' || typeof L !== 'number' ? '-' : (isFinite(L)? L.toFixed(4) : '∞'));
}

document.getElementById('btn-gen').addEventListener('click', ()=>{
  showError(null);
  updateStats(null, null);

  // read inputs
  const n = parseInt(document.getElementById('inp-n').value, 10);
  const k = parseInt(document.getElementById('inp-k').value, 10);
  let p = parseFloat(document.getElementById('inp-p').value);
  const layout = document.getElementById('inp-layout').value;

  if(Number.isNaN(n) || n <= 0) return showError("n must be a positive integer.");
  if(Number.isNaN(k) || k <= 0) return showError("k must be a positive even integer.");
  if(k % 2 !== 0) return showError("k must be even.");
  if(k > n) return showError("k must be less than n.");
  if(Number.isNaN(p) || p < 0 || p > 1) return showError("p must be a number between 0 and 1 (e.g., 0.1).");

  try {
    const adj = wattsStrogatz(n,k,p,false);
    // compute clustering
    const clust = averageClustering(adj);
    const cc = largestConnectedComponent(adj);
    const L = averageShortestPathLengthOnComponent(adj, cc);

    updateStats(clust, L);

    // render
    renderVis(adj, layout);

  } catch(err){
    showError(err.message || String(err));
  }
});

// Download PNG
document.getElementById('btn-download').addEventListener('click', ()=>{
  if(!network) return showError("Generate a graph first.");
  // use network's canvas capture
  const canvas = document.querySelector('#network canvas');
  if(!canvas) return showError("No canvas to download.");
  const link = document.createElement('a');
  link.download = 'ws_graph.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
});


// generate an initial example on load
window.addEventListener('load', ()=>{ document.getElementById('btn-gen').click(); });

</script>
</body>
</html>
